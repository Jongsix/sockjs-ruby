# t BaseUrlGreeting IframePage InfoTest SessionURLs WebsocketHttpErrors JSONEncoding XhrPolling JsonPolling RawWebsocket WebsocketHybi10
# t WebsocketHixie76 # don't mind test_haproxy, it passes on 0.3
# t Protocol
# t XhrStreaming EventSource HtmlFile
# t HandlingClose
# t Http11 Http10

Something like on_close event (up to 2 days):
- "Can I detect that client has closed the connection? I mean if client starts a long request, pulls, pulls and then close it? I'd need some def on_close, is there any way how to do so?"
- "There's no reliable way to know when the client closes the connection. The best way I know is to send a ping (heartbeat) at interval. Once you stop receiving those pings, you know the connection is closed."
- Protocol.test_simpleSession: AssertionError: 'a[]\n' != 'c[2010,"Another connection still open"]\n'. The problem is that we close the first connection sending 'a[""]\n' which is really, really wrong, it's supposed to hang. None the less we MUST NOT block the whole thread. It should not be a problem as Thin is EventMachine-based, but we must make sure it's alright.
- HandlingClose.test_abort_xhr_polling: AssertionError: 'a[]\n' != 'c[2010,"Another connection still open"]\n'
- HandlingClose.test_abort_xhr_streaming: self.assertTrue(r3.read() in ['o\n', 'c[1002,"Connection interrupted"]\n'])

GC by closing request (1/2 â€“ 1 day):
- XhrStreaming.test_response_limit
- EventSource.test_response_limit
- HtmlFile.test_response_limit

Keep-Alive (up to 2 days):
- Http11.test_synchronous: [Errno 54] Connection reset by peer.
- Http10.test_synchronous: AssertionError: 'keep-alive' != 'close'

Release (2.5 days):
- Publish to RubyGems.org.
- Short announcement for the RabbitMQ blog (1/2 day).
- Post for RubyInside.com (1 day).
- Real-world example (1 day).
